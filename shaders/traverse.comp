#version 460

layout(constant_id = 2) const uint voxel_tree_height = 8;
layout(constant_id = 3) const uint children_per_edge = 16;
layout(constant_id = 4) const uint side_dim_minus_one = 255;
const uint children_per_node = children_per_edge * children_per_edge * children_per_edge;


// keep in sync with src/renderer.zig
layout(local_size_x_id = 0, local_size_y_id = 1) in;

// keep in sync with src/voxel_octree.zig
const uint root_node_offset = 0;

// keep in sync with src/voxel_octree.zig
struct ChildDescriptor {
    uint color;
    uint node_offset;
};

// keep in sync with src/renderer.zig
layout(push_constant) uniform PushConstantBuffer {
    vec4 forward;
    vec4 up;
    vec4 translation;
} push;

// keep in sync with src/renderer.zig
layout(binding = 0, rgba8) restrict writeonly uniform image2D render_target;

// keep in sync with src/renderer.zig and src/voxel_tree.zig
layout(binding = 1) readonly buffer VoxelTree {
    // Specialization constants do not work on array sizes in structs, so
    // the indexing is performed manually.
    ChildDescriptor[] children;
} tree;

const uint float_mantissa_bits = 23;

ChildDescriptor getChildDescriptor(uint node_offset, uvec3 child_index) {
    uint child_offset = (child_index.x * children_per_edge + child_index.y) * children_per_edge + child_index.z;
    return tree.children[node_offset * children_per_node + child_offset];
}

vec3 adjustRay(in vec3 rd) {
    const float epsilon = exp2(-float(float_mantissa_bits));
    return mix(rd, vec3(epsilon), lessThan(abs(rd), vec3(epsilon)));
}

vec3 ray(in vec3 forward, in vec3 up, in vec2 uv, in vec2 dim) {
    uv -= 0.5;
    uv.y *= dim.y / dim.x;

    vec3 right = normalize(cross(forward, up));
    vec3 up_adjusted = normalize(cross(right, forward));

    vec3 rd = normalize(uv.x * right + uv.y * up_adjusted + forward);
    return adjustRay(rd);
}

vec4 traverseInt(in uvec3 pos) {
    uint parent_offset = root_node_offset;
    uint child_side_dim = side_dim_minus_one / children_per_edge + 1;

    while (true) {
        uvec3 child_index = pos / child_side_dim;

        ChildDescriptor child = getChildDescriptor(parent_offset, child_index);
        if (child.node_offset == root_node_offset) {
            return unpackUnorm4x8(child.color);
        }

        pos %= child_side_dim;
        parent_offset = child.node_offset;
        child_side_dim /= children_per_edge;
    }
}

float minElement(vec3 x) {
    return min(x.x, min(x.y, x.z));
}

float maxElement(vec3 x) {
    return max(x.x, max(x.y, x.z));
}

vec3 trace(vec3 ro, vec3 rd) {
    vec3 rrd = 1.0 / rd;
    vec3 bias = rrd * ro;

    vec3 box_min = -bias;
    vec3 box_max = vec3(side_dim_minus_one + 1) * rrd - bias;

    float t_min = maxElement(min(box_min, box_max));
    float t_max = minElement(max(box_min, box_max));

    if (t_min > t_max) {
        // Ray misses bounding cube
        return rd;
    }

    t_min = max(t_min, 0);
    t_min += 0.0001;
    t_max -= 0.0001;

    ro += rd * t_min;
    ivec3 pos = ivec3(ro);

    vec3 t_delta = abs(rrd);
    vec3 sgn = sign(rd);
    ivec3 step = ivec3(sgn);
    vec3 side_dist = (sgn * (floor(ro) - ro + 0.5) + 0.5) * t_delta;

    float t = 0;

    while (t < t_max - t_min) {
        bvec3 mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));

        float t0 = minElement(side_dist);
        vec4 color = traverseInt(uvec3(pos));
        if (color.a > 0.5) {
            return color.rgb;
        }

        t = t0;

        side_dist += mix(vec3(0), t_delta, mask);
        pos += mix(ivec3(0), step, mask);
    }

    return rd;
}

void main() {
    uvec2 index = gl_GlobalInvocationID.xy;
    uvec2 render_target_dim = imageSize(render_target);
    if (any(greaterThanEqual(index, render_target_dim))) {
        return;
    }

    vec2 dim = vec2(render_target_dim);
    vec2 uv = vec2(index) / dim;
    vec3 rd = ray(push.forward.xyz, push.up.xyz, uv, dim);
    vec3 ro = push.translation.xyz;

    vec3 color = trace(ro, rd);

    imageStore(render_target, ivec2(index), vec4(color, 1));
}
